"""
This type stub file was generated by pyright.
"""

from collections import defaultdict

def merge_specs(target, source): # -> None:
    """
    Update target dictionary with values from the source, recursively.
    List items will be merged.
    """
    ...

def get_schema_specs(schema_id, swagger): # -> None:
    ...

def get_specs(rules, ignore_verbs, optional_fields, sanitizer, openapi_version, doc_dir=...):
    ...

def swag_from(specs=..., filetype=..., endpoint=..., methods=..., validation=..., schema_id=..., data=..., definition=..., validation_function=..., validation_error_handler=...): # -> Callable[..., _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any]]:
    """
    Takes a filename.yml, a dictionary or object and loads swagger specs.

    :param specs: a filepath, a dictionary or an object
    :param filetype: yml or yaml (json and py to be implemented)
    :param endpoint: endpoint to build definition name
    :param methods: method to build method based specs
    :param validation: perform validation?
    :param schema_id: Definition id ot name to use for validation
    :param data: data to validate (default is request.json)
    :param definition: alias to schema_id
    :param validation_function:
        custom validation function which takes the positional
        arguments: data to be validated at first and schema to validate
        against at second
    :param validation_error_handler: custom function to handle
        exceptions thrown when validating which takes the exception
        thrown as the first, the data being validated as the second and
        the schema being used to validate as the third argument
    """
    ...

def validate(data=..., schema_id=..., filepath=..., root=..., definition=..., specs=..., validation_function=..., validation_error_handler=..., require_data=..., openapi_version=...):
    """
    This method is available to use YAML swagger definitions file
    or specs (dict or object) to validate data against its jsonschema.

    example:
        validate({"item": 1}, 'item_schema', 'defs.yml', root=__file__)
        validate(request.json, 'User', specs={'definitions': {'User': ...}})

    :param data: data to validate, by default is request.json
    :param schema_id: The definition id to use to validate (from specs)
    :param filepath: definition filepath to load specs
    :param root: root folder (inferred if not provided), unused if path
        starts with `/`
    :param definition: Alias to schema_id (kept for backwards
        compatibility)
    :param specs: load definitions from dict or object passed here
        instead of a file.
    :param validation_function: custom validation function which takes
        the positional arguments: data to be validated at first and
        schema to validate against at second
    :param validation_error_handler: custom function to handle
        exceptions thrown when validating which takes the exception
        thrown as the first, the data being validated as the second and
        the schema being used to validate as the third argument
    :param require_data: is the data param required?
    """
    ...

def apispec_to_template(app, spec, definitions=..., paths=...): # -> dict[Any, Any]:
    """
    Converts apispec object in to flasgger definitions template
    :param app: Current app
    :param spec: apispec.APISpec
    :param definitions: a list of [Schema, ..] or [('Name', Schema), ..]
    :param paths: A list of flask views
    """
    ...

def ordered_dict_to_dict(d): # -> dict[Any, Any]:
    """
    Converts inner OrderedDict to bare dict
    """
    ...

def remove_suffix(fpath):
    """Remove all file ending suffixes"""
    ...

def is_python_file(fpath): # -> bool:
    """Naive Python module filterer"""
    ...

def pathify(basenames, examples_dir=...): # -> list[Any]:
    """*nix to python module path"""
    ...

def get_examples(examples_dir=...): # -> list[ModuleType]:
    """All example modules"""
    ...

def get_path_from_doc(full_doc): # -> tuple[Any, Any]:
    """
    If `file:` is provided import the file.
    """
    ...

def json_to_yaml(content):
    """
    TODO: convert json to yaml
    """
    ...

def load_from_file(swag_path, swag_type=..., root_path=...): # -> str:
    """
    Load specs from YAML file
    """
    ...

def detect_by_bom(path, default=...): # -> str:
    ...

def parse_docstring(obj, process_doc, endpoint=..., verb=...): # -> tuple[Any | None, Any | None, Any | None]:
    """
    Gets swag data for method/view docstring
    """
    ...

def get_root_path(obj): # -> str:
    """
    Get file path for object and returns its dirname
    """
    ...

def parse_definition_docstring(obj, process_doc): # -> tuple[Any | None, Any | None]:
    """
    Gets swag data from docstring for class based definitions
    """
    ...

def parse_imports(full_doc, root_path=...):
    """
    Supports `import: otherfile.yml` in docstring specs
    """
    ...

def extract_definitions(alist, level=..., endpoint=..., verb=..., prefix_ids=..., openapi_version=...): # -> list[Any]:
    """
    Since we couldn't be bothered to register models elsewhere
    our definitions need to be extracted from the parameters.
    We require an 'id' field for the schema to be correctly
    added to the definitions list.
    """
    ...

def has_valid_dispatch_view_docs(endpoint): # -> Any | Literal[False]:
    """
    Return True if dispatch_request is swaggable
    """
    ...

def is_valid_method_view(endpoint): # -> bool:
    """
    Return True if obj is MethodView
    """
    ...

def get_vendor_extension_fields(mapping): # -> dict[Any, Any]:
    """
    Identify vendor extension fields and extract them into a new dictionary.
    Examples:
        >>> get_vendor_extension_fields({'test': 1})
        {}
        >>> get_vendor_extension_fields({'test': 1, 'x-test': 2})
        {'x-test': 2}
    """
    ...

class StringLike:
    """
    Class to mimic the behavior of a regular string. Classes that inherit (or
    mixin) this class must implement the `__str__` magic method. Whatever that
    method returns is used by the various string-like methods.
    """
    def __getattr__(self, attr): # -> Any:
        """
        Forwards any non-magic methods to the resulting string's class. This
        allows support for string methods like `upper()`, `lower()`, etc.
        """
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __getitem__(self, key): # -> str:
        ...
    
    def __iter__(self): # -> Iterator[str]:
        ...
    
    def __contains__(self, item): # -> bool:
        ...
    
    def __add__(self, other):
        ...
    
    def __radd__(self, other):
        ...
    
    def __mul__(self, other):
        ...
    
    def __rmul__(self, other):
        ...
    
    def __lt__(self, other) -> bool:
        ...
    
    def __le__(self, other) -> bool:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def __gt__(self, other) -> bool:
        ...
    
    def __ge__(self, other) -> bool:
        ...
    
    @property
    def text_type(self): # -> text_type:
        ...
    


class LazyString(StringLike):
    """
    A lazy string *without* caching. The resulting string is regenerated for
    every request.
    """
    def __init__(self, func) -> None:
        """
        Creates a `LazyString` object using `func` as the delayed closure.
        `func` must return a string.
        """
        ...
    
    def __str__(self) -> str:
        """
        Returns the actual string.
        """
        ...
    


class CachedLazyString(LazyString):
    """
    A lazy string with caching.
    """
    def __init__(self, func) -> None:
        """
        Uses `__init__()` from the parent and initializes a cache.
        """
        ...
    
    def __str__(self) -> str:
        """
        Returns the actual string and caches the result.
        """
        ...
    


def swag_annotation(f): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any]:
    ...

def validate_annotation(an, var): # -> Callable[..., _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any]]:
    ...

def is_openapi3(openapi_version): # -> bool:
    """
    Returns True if openapi_version is 3
    """
    ...

def extract_schema(spec: dict) -> defaultdict:
    """
    Returns schema resources according to openapi version
    """
    ...

